<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chessboard Vocal Trainer</title>
  <style>
    :root {
      --accent: #d73535;     /* rosso evidenza casella */
      --accent-glow: rgba(215, 53, 53, 0.55);
      --light: #eee;
      --dark: #666;

      /* Colori selezione area */
      --sel-fill: rgba(0, 120, 255, 0.28);
      --sel-border: #0078ff;
      --sel-glow: rgba(0, 120, 255, 0.55);
      --area-outline: #0078ff;
      --area-overlay: rgba(0, 120, 255, 0.2);
    }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
      color: #222;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .page {
      min-height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
      padding: 16px;
    }
    h1 {
      margin: 4px 0 0 0;
      font-size: clamp(18px, 2.5vw, 28px);
      font-weight: 700;
      text-align: center;
    }
    .status {
      min-height: 1.8em;
      font-size: clamp(16px, 2vw, 22px);
      font-weight: 700;
      text-align: center;
    }
    .controls {
      display: none; /* visibile solo con selezione */
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
    }
    .controls.visible { display: flex; }
    .btn {
      appearance: none;
      border: 1px solid #333;
      background: #fff;
      color: #222;
      padding: 8px 12px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
    }
    .btn:hover { background: #f0f0f0; }
    .hint {
      font-size: clamp(12px, 1.6vw, 16px);
      color: #555;
      text-align: center;
    }
    .board-wrap {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .board {
      --side: min(92vw, 80vh);
      width: var(--side);
      height: var(--side);
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border: 3px solid #333;
      background: #333;
      box-shadow: 0 0 14px rgba(0,0,0,0.25);
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      border-radius: 6px;
      position: relative;
      overflow: hidden;
      user-select: none;
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      font-weight: 700;
      font-size: clamp(10px, 2.2vw, 16px);
      position: relative;
      z-index: 0; /* base layer */
    }
    .white { background: var(--light); color: rgba(0,0,0,0.55); }
    .black { background: var(--dark); color: rgba(255,255,255,0.8); }

    /* Overlay blu area selezionata: sotto all'highlight rosso */
    .in-area::after {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--area-overlay);
      box-shadow: inset 0 0 0 3px var(--area-outline);
      border-radius: 4px;
      pointer-events: none;
      z-index: 1;
    }

    /* Highlight rosso a prova di overlay: due layer sopra tutto */
    .highlight { z-index: 999; }
    .highlight::before,
    .highlight::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    .highlight::before {
      box-shadow:
        inset 0 0 0 4px var(--accent),
        inset 0 0 0 6px rgba(0,0,0,0);
      border-radius: 4px;
      z-index: 1000;
    }
    .highlight::after {
      box-shadow: 0 0 10px 4px var(--accent-glow);
      inset: -2px;
      border-radius: 6px;
      z-index: 1001;
    }

    /* Durante il drag: anteprima candidate (sotto al rosso) */
    .candidate::after {
      content: '';
      position: absolute;
      inset: 0;
      background: var(--area-overlay);
      box-shadow: inset 0 0 0 3px var(--area-outline);
      border-radius: 4px;
      pointer-events: none;
      z-index: 1;
    }

    /* Rettangolo selezione: animato SOLO durante il drag, statico dopo */
    .sel-box {
      position: absolute;
      pointer-events: none;
      border-radius: 6px;
      display: none;
    }
    .sel-box.selecting {
      border: 3px dashed var(--sel-border);
      background: var(--sel-fill);
      box-shadow: 0 0 0 3px var(--sel-glow), 0 0 16px var(--sel-glow);
      animation: selDash 1s linear infinite;
    }
    .sel-box.selected {
      border: 3px solid var(--sel-border);
      background: rgba(0, 120, 255, 0.12);
      box-shadow: none;
      animation: none;
    }
    @keyframes selDash {
      0% { outline-offset: 0; }
      100% { outline-offset: -16px; }
    }

    @media (min-width: 900px) {
      .page { padding-top: 24px; }
      .board { --side: min(70vh, 70vw); }
    }
  </style>
</head>
<body>
  <div class="page">
    <h1>Chessboard Vocal Trainer</h1>
    <div class="status" id="status">Tocca la scacchiera per iniziare (mobile/tablet) oppure premi SPAZIO (desktop)</div>

    <div class="controls" id="controls">
      <button class="btn" id="clearSel">Azzera selezione</button>
    </div>

    <div class="board-wrap">
      <div class="board" id="board" aria-label="Scacchiera, tocca o premi spazio per avanzare" role="button" tabindex="0">
        <div class="sel-box" id="selBox"></div>
      </div>
    </div>

    <div class="hint" id="hint">Tocca la scacchiera (mobile) o premi Spazio (desktop): coord → colore → nuova casella casuale.</div>
  </div>

  <script>
    // Dati scacchiera
    const files = ['a','b','c','d','e','f','g','h'];
    const ranks = [1,2,3,4,5,6,7,8];

    const boardEl     = document.getElementById('board');
    const statusEl    = document.getElementById('status');
    const selBoxEl    = document.getElementById('selBox');
    const controlsEl  = document.getElementById('controls');
    const clearSelBtn = document.getElementById('clearSel');

    function colorFor(fileIndex, rankNumber) {
      const isDark = (fileIndex + rankNumber) % 2 === 1; // a1 nero
      return isDark ? 'nero' : 'bianco';
    }

    // Costruzione scacchiera
    let allSquares = [];
    (function buildBoard() {
      for (let r = 7; r >= 0; r--) {
        for (let f = 0; f < 8; f++) {
          const coord = files[f] + ranks[r];
          const colorName = colorFor(f, ranks[r]);
          const el = document.createElement('div');
          el.className = 'square ' + (colorName === 'nero' ? 'black' : 'white');
          el.textContent = coord;
          el.setAttribute('data-coord', coord);
          el.setAttribute('data-f', String(f));
          el.setAttribute('data-r', String(r));
          boardEl.appendChild(el);
          allSquares.push({ coord, color: colorName, element: el, f, r, rankNum: ranks[r] });
        }
      }
    })();

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    // Selezione cumulativa: unione di aree
    const selectedKeys = new Set(); // coord come chiave
    function squareKey(s) { return s.coord; }

    function applySelectedVisuals() {
      allSquares.forEach(s => s.element.classList.toggle('in-area', selectedKeys.has(squareKey(s))));
      controlsEl.classList.toggle('visible', selectedKeys.size > 0);
    }

    let activeSquares = allSquares.slice();
    shuffle(activeSquares);

    // Stato quiz
    let index = 0;        // indice in activeSquares
    let state = 0;        // 0 = coordinata, 1 = colore
    let lastTapTime = 0;
    let handling = false;
    let touchFired = false;

    function speak(text) {
      try {
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = 'it-IT';
        speechSynthesis.cancel();
        speechSynthesis.speak(utter);
      } catch (e) {}
    }

    function clearHighlights() {
      allSquares.forEach(s => s.element.classList.remove('highlight'));
    }

    function rebuildActiveFromSelection() {
      activeSquares = (selectedKeys.size === 0)
        ? allSquares.slice()
        : allSquares.filter(s => selectedKeys.has(squareKey(s)));
      shuffle(activeSquares);
      index = 0;
      state = 0;
      applySelectedVisuals();
    }

    function step() {
      if (handling) return;
      handling = true;
      try {
        if (activeSquares.length === 0) {
          statusEl.textContent = 'Seleziona un\'area valida (almeno una casella).';
          return;
        }
        const current = activeSquares[index];

        if (state === 0) {
          clearHighlights();
          statusEl.textContent = 'Casella: ' + current.coord;
          speak('Casella ' + current.coord);
          state = 1;
        } else {
          clearHighlights();
          current.element.classList.add('highlight'); // rosso sopra overlay
          statusEl.textContent = 'Colore: ' + current.color;
          speak('Colore ' + current.color);
          state = 0;
          index++;
          if (index >= activeSquares.length) {
            shuffle(activeSquares);
            index = 0;
          }
        }
      } finally {
        setTimeout(() => { handling = false; }, 50);
      }
    }

    // Input: Space desktop
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        step();
      }
    });

    // Tap/click
    function handleTap() {
      const now = Date.now();
      if (now - lastTapTime < 250) return;
      lastTapTime = now;
      step();
    }
    boardEl.addEventListener('touchstart', () => { touchFired = true; }, { passive: true });
    boardEl.addEventListener('click', () => {
      if (selecting) return;
      if (touchFired) { touchFired = false; handleTap(); return; }
      handleTap();
    });
    boardEl.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.code === 'Enter') {
        e.preventDefault();
        step();
      }
    });

    // Selezione aree (cumulativa) con feedback
    let selecting = false;
    let dragStart = null; // {f,r}
    let dragEnd = null;   // {f,r}

    function hitSquareFromPoint(clientX, clientY) {
      const rect = boardEl.getBoundingClientRect();
      const x = clientX - rect.left;
      const y = clientY - rect.top;
      if (x < 0 || y < 0 || x > rect.width || y > rect.height) return null;
      const f = Math.floor((x / rect.width) * 8);
      const rFromTop = Math.floor((y / rect.height) * 8);
      const r = 7 - rFromTop; // 7 in alto … 0 in basso
      return { f: Math.max(0, Math.min(7, f)), r: Math.max(0, Math.min(7, r)) };
    }

    function updateSelBoxFromFR(start, end, selectedStatic = false) {
      const rect = boardEl.getBoundingClientRect();
      const tileW = rect.width / 8;
      const tileH = rect.height / 8;

      const fMin = Math.min(start.f, end.f);
      const fMax = Math.max(start.f, end.f);
      const rMin = Math.min(start.r, end.r);
      const rMax = Math.max(start.r, end.r);

      const x = fMin * tileW;
      const y = (7 - rMax) * tileH;
      const w = (fMax - fMin + 1) * tileW;
      const h = (rMax - rMin + 1) * tileH;

      selBoxEl.style.left = x + 'px';
      selBoxEl.style.top = y + 'px';
      selBoxEl.style.width = w + 'px';
      selBoxEl.style.height = h + 'px';
      selBoxEl.style.display = 'block';
      selBoxEl.classList.remove('selecting', 'selected');
      selBoxEl.classList.add(selectedStatic ? 'selected' : 'selecting');
    }

    function markCandidates(start, end) {
      allSquares.forEach(s => s.element.classList.remove('candidate'));
      const fMin = Math.min(start.f, end.f);
      const fMax = Math.max(start.f, end.f);
      const rMin = Math.min(start.r, end.r);
      const rMax = Math.max(start.r, end.r);
      allSquares.forEach(s => {
        if (s.f >= fMin && s.f <= fMax && s.r >= rMin && s.r <= rMax) {
          s.element.classList.add('candidate');
        }
      });
    }

    function beginSelectionAt(clientX, clientY) {
      const hit = hitSquareFromPoint(clientX, clientY);
      if (!hit) return;
      selecting = true;
      dragStart = { f: hit.f, r: hit.r };
      dragEnd = { f: hit.f, r: hit.r };
      updateSelBoxFromFR(dragStart, dragEnd, false); // animato durante drag
      markCandidates(dragStart, dragEnd);
    }

    function updateSelectionAt(clientX, clientY) {
      if (!selecting || !dragStart) return;
      const hit = hitSquareFromPoint(clientX, clientY);
      if (!hit) return;
      dragEnd = { f: hit.f, r: hit.r };
      updateSelBoxFromFR(dragStart, dragEnd, false);
      markCandidates(dragStart, dragEnd);
    }

    function endSelection() {
      if (!selecting) return;
      selecting = false;
      updateSelBoxFromFR(dragStart, dragEnd, true); // statico dopo rilascio

      // Aggiungi caselle dell’area al set (UNIONE)
      const fMin = Math.min(dragStart.f, dragEnd.f);
      const fMax = Math.max(dragStart.f, dragEnd.f);
      const rMin = Math.min(dragStart.r, dragEnd.r);
      const rMax = Math.max(dragStart.r, dragEnd.r);
      allSquares.forEach(s => {
        if (s.f >= fMin && s.f <= fMax && s.r >= rMin && s.r <= rMax) {
          selectedKeys.add(squareKey(s));
        }
      });

      // Pulisci anteprima e applica visuali definitive
      allSquares.forEach(s => s.element.classList.remove('candidate'));
      applySelectedVisuals();
      rebuildActiveFromSelection();

      // IMPORTANTE: non avviare alcuna chiamata; attendi input utente
      const count = activeSquares.length;
      statusEl.textContent = `Area selezionata: ${count} casella${count !== 1 ? 'e' : ''}. Tocca/Spazio per iniziare.`;
      // Non chiamare step() qui.
    }

    // Mouse drag
    boardEl.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      e.preventDefault();
      beginSelectionAt(e.clientX, e.clientY);
    });
    window.addEventListener('mousemove', (e) => {
      if (!selecting) return;
      e.preventDefault();
      updateSelectionAt(e.clientX, e.clientY);
    });
    window.addEventListener('mouseup', (e) => {
      if (!selecting) return;
      e.preventDefault();
      endSelection();
    });

    // Touch drag (una sola dita)
    let selectionTouchId = null;
    boardEl.addEventListener('touchstart', (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      selectionTouchId = t.identifier;
      beginSelectionAt(t.clientX, t.clientY);
    }, { passive: true });

    boardEl.addEventListener('touchmove', (e) => {
      if (selectionTouchId == null) return;
      for (const t of e.changedTouches) {
        if (t.identifier === selectionTouchId) {
          updateSelectionAt(t.clientX, t.clientY);
          break;
        }
      }
    }, { passive: true });

    boardEl.addEventListener('touchend', (e) => {
      if (selectionTouchId == null) return;
      for (const t of e.changedTouches) {
        if (t.identifier === selectionTouchId) {
          selectionTouchId = null;
          endSelection();
          break;
        }
      }
    }, { passive: true });

    // Azzera selezione (visibile solo se c'è selezione)
    clearSelBtn.addEventListener('click', () => {
      selectedKeys.clear();
      selBoxEl.style.display = 'none';
      selBoxEl.classList.remove('selecting', 'selected');
      applySelectedVisuals();
      rebuildActiveFromSelection();
      statusEl.textContent = 'Selezione azzerata. Tocca/Spazio per iniziare.';
    });

    // Stato iniziale
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    statusEl.textContent = isTouch
      ? 'Tocca la scacchiera per iniziare. Trascina per selezionare aree (si sommano).'
      : 'Premi SPAZIO o clic per iniziare. Trascina il mouse per selezionare aree (si sommano).';

    // Evita zoom su doppio tap iOS
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
  </script>
</body>
</html>
